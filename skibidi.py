# skibidi_fixed_v3_full_embed_v2style.py
import os
import discord
from discord.ext import commands, tasks
from datetime import datetime, timezone
import sqlite3
from flask import Flask
from waitress import serve
from threading import Thread
import pathlib
import csv
import asyncio

# ===== Path DB =====
BASE_DIR = pathlib.Path(__file__).parent
DB_PATH = BASE_DIR / "inactivity.db"

# ===== Config =====
TOKEN = os.getenv("TOKEN")
ROLE_NAME = "üí§ T√≠n ƒê·ªì Ng·ªß ƒê√¥ng"
INACTIVE_DAYS = 30

# ===== Intents =====
intents = discord.Intents.default()
intents.members = True
intents.guilds = True
intents.presences = True
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

# ===== Flask server (·ªïn ƒë·ªãnh cho UptimeRobot) =====
app = Flask(__name__)

@app.route("/")
def home():
    return "üü¢ Bot ƒëang ch·∫°y ·ªïn ƒë·ªãnh (Skibidi_v3)!"

def run_flask():
    port = int(os.environ.get("PORT", 8080))
    try:
        serve(app, host="0.0.0.0", port=port, _quiet=True)
    except Exception as e:
        print(f"‚ö†Ô∏è Flask l·ªói: {e}")

# ===== Database =====
def get_db_connection():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

with get_db_connection() as conn:
    conn.execute("""
    CREATE TABLE IF NOT EXISTS inactivity (
        member_id TEXT PRIMARY KEY,
        guild_id TEXT,
        last_seen TEXT,
        role_added INTEGER DEFAULT 0
    )
    """)
print(f"üü¢ Database SQLite s·∫µn s√†ng: {DB_PATH}")

# ===== Helper =====
def make_embed(title: str, description: str = None, color=discord.Color.blue(), *, fields=None, footer=None):
    embed = discord.Embed(title=title, description=description or "", color=color, timestamp=datetime.now(timezone.utc))
    if fields:
        for name, value, inline in fields:
            embed.add_field(name=name, value=value, inline=inline)
    if footer:
        embed.set_footer(text=footer)
    return embed

# ===== Custom Help Embed (Phoebe style) =====
class FancyHelpCommand(commands.MinimalHelpCommand):
    async def send_bot_help(self, mapping):
        embed = discord.Embed(
            title="üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Bot",
            description="D∆∞·ªõi ƒë√¢y l√† danh s√°ch c√°c l·ªánh kh·∫£ d·ª•ng, chia theo nh√≥m:",
            color=discord.Color.from_rgb(125, 78, 255)
        )
        bot_avatar = self.context.bot.user.avatar.url if self.context.bot.user and self.context.bot.user.avatar else None
        embed.set_thumbnail(url="https://files.catbox.moe/rvvejl.png")
        embed.set_image(url="https://moewalls.com/wp-content/uploads/2025/03/phoebe-sleeping-wuthering-waves-thumb.jpg")

        for cog, commands_list in mapping.items():
            filtered = await self.filter_commands(commands_list, sort=True)
            if not filtered:
                continue
            embed.add_field(
                name=f"‚öôÔ∏è {cog.qualified_name if cog else 'L·ªánh chung'}",
                value="\n".join(f"**!{cmd.name}** ‚Äî {cmd.help or 'Kh√¥ng c√≥ m√¥ t·∫£'}" for cmd in filtered),
                inline=False
            )

        embed.set_footer(text="üí° D√πng !help <t√™n l·ªánh> ƒë·ªÉ xem chi ti·∫øt c·ª• th·ªÉ.")
        await self.get_destination().send(embed=embed)

    async def send_command_help(self, command):
        embed = discord.Embed(
            title=f"‚ùî Chi ti·∫øt l·ªánh: !{command.name}",
            color=discord.Color.green()
        )
        embed.add_field(name="üìÑ M√¥ t·∫£", value=command.help or "Kh√¥ng c√≥ m√¥ t·∫£", inline=False)
        embed.add_field(name="üì¶ C√∫ ph√°p", value=f"`!{command.name} {command.signature}`", inline=False)
        await self.get_destination().send(embed=embed)

bot.remove_command("help")
bot.help_command = FancyHelpCommand()

# ===== Ki·ªÉm tra inactivity =====
async def check_inactivity_once(ctx=None, only_over_30=False):
    now = datetime.now(timezone.utc)
    print(f"üîç [{now.isoformat()}] B·∫Øt ƒë·∫ßu ki·ªÉm tra inactivity...")
    total_checked = total_updated = total_role_added = 0
    try:
        conn = get_db_connection()
        c = conn.cursor()
        for guild in bot.guilds:
            role = discord.utils.get(guild.roles, name=ROLE_NAME)
            if not role:
                print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y role '{ROLE_NAME}' trong '{guild.name}'")
                continue
            for member in guild.members:
                if member.bot:
                    continue
                total_checked += 1
                try:
                    c.execute("SELECT last_seen, role_added FROM inactivity WHERE member_id=?", (str(member.id),))
                    row = c.fetchone()
                    last_seen, role_added = (row["last_seen"], row["role_added"]) if row else (None, 0)

                    if str(member.status) == "offline":
                        c.execute("""
                            INSERT INTO inactivity (member_id, guild_id, last_seen, role_added)
                            VALUES (?, ?, ?, ?)
                            ON CONFLICT(member_id) DO UPDATE SET last_seen=excluded.last_seen
                        """, (str(member.id), str(guild.id), datetime.now(timezone.utc).isoformat(), role_added))
                        total_updated += 1

                    if last_seen:
                        last_seen_dt = datetime.fromisoformat(last_seen)
                        days_off = (now - last_seen_dt).days
                        if days_off >= INACTIVE_DAYS and role_added == 0:
                            if not only_over_30 or days_off >= INACTIVE_DAYS:
                                await member.add_roles(role)
                                c.execute("UPDATE inactivity SET role_added=1 WHERE member_id=?", (str(member.id),))
                                total_role_added += 1
                                print(f"‚úÖ G√°n role '{ROLE_NAME}' cho {member.name} ({days_off} ng√†y)")
                except Exception as e:
                    print(f"‚ö†Ô∏è L·ªói x·ª≠ l√Ω {member.name}: {e}")
                if total_checked % 100 == 0:
                    await asyncio.sleep(0.1)
        conn.commit()
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói trong check_inactivity_once: {e}")
    finally:
        conn.close()
    print(f"‚úÖ Ho√†n t·∫•t. Checked={total_checked} Updated={total_updated} RoleAdded={total_role_added}")
    if ctx:
        embed = make_embed(
            title="‚úÖ Ho√†n t·∫•t ki·ªÉm tra Inactivity",
            color=discord.Color.green(),
            fields=[
                ("üßæ T·ªïng ki·ªÉm tra", str(total_checked), True),
                ("üîÑ C·∫≠p nh·∫≠t last_seen", str(total_updated), True),
                ("‚úÖ G√°n role", str(total_role_added), True)
            ],
            footer="S·ª≠ d·ª•ng !recheck30days ƒë·ªÉ ki·ªÉm tra l·∫°i nh·ªØng ng∆∞·ªùi ƒë√£ >=30 ng√†y."
        )
        await ctx.send(embed=embed)

# ===== Task ƒë·ªãnh k·ª≥ =====
@tasks.loop(hours=24)
async def check_inactivity():
    try:
        await check_inactivity_once()
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói trong task ƒë·ªãnh k·ª≥: {e}")

# ===== Commands =====
@bot.command(help="Xu·∫•t database inactivity th√†nh file CSV c√≥ t√™n ng∆∞·ªùi d√πng")
@commands.has_permissions(administrator=True)
async def exportcsv(ctx):
    csv_path = BASE_DIR / "inactivity_export.csv"
    conn = get_db_connection()
    c = conn.cursor()
    c.execute("SELECT member_id, guild_id, last_seen, role_added FROM inactivity")
    rows = c.fetchall()
    conn.close()

    if not rows:
        await ctx.send("‚ö†Ô∏è Database tr·ªëng.")
        return

    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["member_id", "member_name", "guild_id", "last_seen", "role_added"])
        for row in rows:
            guild = bot.get_guild(int(row["guild_id"]))
            member = guild.get_member(int(row["member_id"])) if guild else None
            name = f"{member.name}#{member.discriminator}" if member else "Kh√¥ng t√¨m th·∫•y"
            writer.writerow([row["member_id"], name, row["guild_id"], row["last_seen"], row["role_added"]])
    with open(csv_path, "rb") as f:
        await ctx.send(file=discord.File(f, filename="inactivity_export.csv"))
    os.remove(csv_path)

@bot.command(help="Ch·∫°y ki·ªÉm tra inactivity ngay l·∫≠p t·ª©c")
@commands.has_permissions(administrator=True)
async def runcheck(ctx):
    await ctx.send(embed=make_embed(title="üîé ƒêang ki·ªÉm tra...", color=discord.Color.blue()))
    await check_inactivity_once(ctx)
    await ctx.send(embed=make_embed(title="‚úÖ Ho√†n t·∫•t ki·ªÉm tra th·ªß c√¥ng", color=discord.Color.green()))

@bot.command(help="Ki·ªÉm tra l·∫°i nh·ªØng ng∆∞·ªùi ƒë√£ offline >= 30 ng√†y")
@commands.has_permissions(administrator=True)
async def recheck30days(ctx):
    await ctx.send(embed=make_embed(title="üîÅ ƒêang ki·ªÉm tra l·∫°i nh·ªØng ng∆∞·ªùi ƒë√£ offline ‚â• 30 ng√†y...", color=discord.Color.blue()))
    await check_inactivity_once(ctx, only_over_30=True)
    await ctx.send(embed=make_embed(title="‚úÖ Ho√†n t·∫•t recheck", color=discord.Color.green()))

@bot.command(help="G·ª≠i file database SQLite (.db)")
@commands.has_permissions(administrator=True)
async def exportdb(ctx):
    if os.path.exists(DB_PATH):
        await ctx.send(file=discord.File(DB_PATH))
    else:
        await ctx.send("‚ùå Kh√¥ng t√¨m th·∫•y file database.")

@bot.command(help="Ki·ªÉm tra bot c√≥ ho·∫°t ƒë·ªông kh√¥ng")
async def test(ctx):
    embed = make_embed(
        title="üß™ Bot Test",
        description="‚úÖ Bot ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng v√† t·ª± ki·ªÉm tra inactivity m·ªói 24 gi·ªù.",
        color=discord.Color.green(),
        fields=[("üïì L·ªãch ki·ªÉm tra", "24 gi·ªù/l·∫ßn", True)],
        footer="D√πng !runcheck ƒë·ªÉ ki·ªÉm tra ngay."
    )
    embed.set_thumbnail(url="https://files.catbox.moe/rvvejl.png")
    await ctx.send(embed=embed)

# ===== Event =====
@bot.event
async def on_ready():
    print(f"ü§ñ Bot {bot.user} ƒë√£ online!")
    await bot.change_presence(activity=discord.Game("Theo d√µi t√≠n ƒë·ªì üò¥"))
    if not check_inactivity.is_running():
        check_inactivity.start()
        print("üü¢ Task check_inactivity ƒë√£ start")

# ===== Run =====
if __name__ == "__main__":
    Thread(target=run_flask, daemon=True).start()
    print("üü¢ Flask server ƒëang ch·∫°y n·ªÅn (daemon).")
    if TOKEN:
        print("üü¢ Kh·ªüi ch·∫°y bot...")
        bot.run(TOKEN)
    else:
        print("‚ùå Thi·∫øu TOKEN trong bi·∫øn m√¥i tr∆∞·ªùng!")
