# skibidi_fixed_v3_full_embed_v2style.py
import os
import discord
from discord.ext import commands, tasks
from datetime import datetime, timezone
import sqlite3
from flask import Flask
from waitress import serve
from threading import Thread
import pathlib
import csv
import asyncio

# ===== Path DB =====
BASE_DIR = pathlib.Path(__file__).parent
DB_PATH = BASE_DIR / "inactivity.db"

# ===== Config =====
TOKEN = os.getenv("TOKEN")
ROLE_NAME = "üí§ T√≠n ƒê·ªì Ng·ªß ƒê√¥ng"
INACTIVE_DAYS = 30

# ===== Intents =====
intents = discord.Intents.default()
intents.members = True
intents.guilds = True
intents.presences = True
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

# ===== Flask server (·ªïn ƒë·ªãnh cho UptimeRobot) =====
app = Flask(__name__)

@app.route("/")
def home():
    return "üü¢ Bot ƒëang ch·∫°y ·ªïn ƒë·ªãnh (Skibidi_v3)!"

@app.route("/healthz")
def healthz():
    # Route ri√™ng cho Render health check (lu√¥n tr·∫£ 200 OK)
    return "OK", 200

def run_flask():
    port = int(os.environ.get("PORT", 8080))
    try:
        serve(app, host="0.0.0.0", port=port, _quiet=True)
    except Exception as e:
        print(f"‚ö†Ô∏è Flask l·ªói: {e}")

# ===== Database =====
def get_db_connection():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

with get_db_connection() as conn:
    conn.execute("""
    CREATE TABLE IF NOT EXISTS inactivity (
        member_id TEXT PRIMARY KEY,
        guild_id TEXT,
        last_seen TEXT,
        role_added INTEGER DEFAULT 0
    )
    """)
print(f"üü¢ Database SQLite s·∫µn s√†ng: {DB_PATH}")

# ===== Helper =====
def make_embed(title: str, description: str = None, color=discord.Color.blue(), *, fields=None, footer=None):
    embed = discord.Embed(title=title, description=description or "", color=color, timestamp=datetime.now(timezone.utc))
    if fields:
        for name, value, inline in fields:
            embed.add_field(name=name, value=value, inline=inline)
    if footer:
        embed.set_footer(text=footer)
    return embed

# ===== Custom Help Embed (Phoebe style) =====
class FancyHelpCommand(commands.MinimalHelpCommand):
    async def send_bot_help(self, mapping):
        embed = discord.Embed(
            title="üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Bot",
            description="D∆∞·ªõi ƒë√¢y l√† danh s√°ch c√°c l·ªánh kh·∫£ d·ª•ng, chia theo nh√≥m:",
            color=discord.Color.from_rgb(125, 78, 255)
        )
        bot_avatar = self.context.bot.user.avatar.url if self.context.bot.user and self.context.bot.user.avatar else None
        embed.set_thumbnail(url="https://files.catbox.moe/rvvejl.png")
        embed.set_image(url="https://moewalls.com/wp-content/uploads/2025/03/phoebe-sleeping-wuthering-waves-thumb.jpg")

        for cog, commands_list in mapping.items():
            filtered = await self.filter_commands(commands_list, sort=True)
            if not filtered:
                continue
            embed.add_field(
                name=f"‚öôÔ∏è {cog.qualified_name if cog else 'L·ªánh chung'}",
                value="\n".join(f"**!{cmd.name}** ‚Äî {cmd.help or 'Kh√¥ng c√≥ m√¥ t·∫£'}" for cmd in filtered),
                inline=False
            )

        embed.set_footer(text="üí° D√πng !help <t√™n l·ªánh> ƒë·ªÉ xem chi ti·∫øt c·ª• th·ªÉ.")
        await self.get_destination().send(embed=embed)

    async def send_command_help(self, command):
        embed = discord.Embed(
            title=f"‚ùî Chi ti·∫øt l·ªánh: !{command.name}",
            color=discord.Color.green()
        )
        embed.add_field(name="üìÑ M√¥ t·∫£", value=command.help or "Kh√¥ng c√≥ m√¥ t·∫£", inline=False)
        embed.add_field(name="üì¶ C√∫ ph√°p", value=f"`!{command.name} {command.signature}`", inline=False)
        await self.get_destination().send(embed=embed)

bot.remove_command("help")
bot.help_command = FancyHelpCommand()

# ===== Ki·ªÉm tra inactivity =====
async def check_inactivity_once(ctx=None, only_over_30=False):
    now = datetime.now(timezone.utc)
    print(f"üîç [{now.isoformat()}] B·∫Øt ƒë·∫ßu ki·ªÉm tra inactivity...")
    total_checked = total_updated = total_role_added = 0
    try:
        conn = get_db_connection()
        c = conn.cursor()
        for guild in bot.guilds:
            role = discord.utils.get(guild.roles, name=ROLE_NAME)
            if not role:
                print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y role '{ROLE_NAME}' trong '{guild.name}'")
                continue
            for member in guild.members:
                if member.bot:
                    continue
                total_checked += 1
                try:
                    c.execute("SELECT last_seen, role_added FROM inactivity WHERE member_id=?", (str(member.id),))
                    row = c.fetchone()
                    last_seen, role_added = (row["last_seen"], row["role_added"]) if row else (None, 0)

                    if str(member.status) == "offline":
                        c.execute("""
                            INSERT INTO inactivity (member_id, guild_id, last_seen, role_added)
                            VALUES (?, ?, ?, ?)
                            ON CONFLICT(member_id) DO UPDATE SET last_seen=excluded.last_seen
                        """, (str(member.id), str(guild.id), datetime.now(timezone.utc).isoformat(), role_added))
                        total_updated += 1

                    if last_seen:
                        last_seen_dt = datetime.fromisoformat(last_seen)
                        days_off = (now - last_seen_dt).days
                        if days_off >= INACTIVE_DAYS and role_added == 0:
                            if not only_over_30 or days_off >= INACTIVE_DAYS:
                                await member.add_roles(role)
                                c.execute("UPDATE inactivity SET role_added=1 WHERE member_id=?", (str(member.id),))
                                total_role_added += 1
                                print(f"‚úÖ G√°n role '{ROLE_NAME}' cho {member.name} ({days_off} ng√†y)")
                except Exception as e:
                    print(f"‚ö†Ô∏è L·ªói x·ª≠ l√Ω {member.name}: {e}")
                if total_checked % 100 == 0:
                    await asyncio.sleep(0.1)
        conn.commit()
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói trong check_inactivity_once: {e}")
    finally:
        conn.close()
    print(f"‚úÖ Ho√†n t·∫•t. Checked={total_checked} Updated={total_updated} RoleAdded={total_role_added}")
    if ctx:
        embed = make_embed(
            title="‚úÖ Ho√†n t·∫•t ki·ªÉm tra Inactivity",
            color=discord.Color.green(),
            fields=[
                ("üßæ T·ªïng ki·ªÉm tra", str(total_checked), True),
                ("üîÑ C·∫≠p nh·∫≠t last_seen", str(total_updated), True),
                ("‚úÖ G√°n role", str(total_role_added), True)
            ],
            footer="S·ª≠ d·ª•ng !recheck30days ƒë·ªÉ ki·ªÉm tra l·∫°i nh·ªØng ng∆∞·ªùi ƒë√£ >=30 ng√†y."
        )
        await ctx.send(embed=embed)

# ===== Task ƒë·ªãnh k·ª≥ =====
@tasks.loop(hours=24)
async def check_inactivity():
    try:
        await check_inactivity_once()
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói trong task ƒë·ªãnh k·ª≥: {e}")

# ===== Commands =====
@bot.command(help="Hi·ªÉn th·ªã th√¥ng tin c·∫•u h√¨nh hi·ªán t·∫°i c·ªßa bot.")
async def config_info(ctx):
    embed = make_embed(
        title="‚öôÔ∏è C·∫•u h√¨nh hi·ªán t·∫°i",
        color=discord.Color.blurple(),
        fields=[
            ("üí§ T√™n Role Inactive", ROLE_NAME, True),
            ("üìÜ S·ªë ng√†y inactive", str(INACTIVE_DAYS), True),
            ("üóÇÔ∏è Database", str(DB_PATH.name), True),
            ("üåê Flask Port", os.environ.get("PORT", "8080"), True),
        ],
        footer="Skibidi Bot v3 Full Embed (Phoebe Style)"
    )
    embed.set_thumbnail(url="https://files.catbox.moe/rvvejl.png")
    await ctx.send(embed=embed)

@bot.command(help="Li·ªát k√™ ho·∫∑c xu·∫•t CSV th√†nh vi√™n offline ‚â• INACTIVE_DAYS (m·∫∑c ƒë·ªãnh 30 ng√†y).")
@commands.has_permissions(administrator=True)
async def list_off_30days(ctx, export: str = None):
    guild = ctx.guild
    conn = get_db_connection()
    c = conn.cursor()
    c.execute("SELECT member_id, last_seen FROM inactivity WHERE guild_id=?", (str(guild.id),))
    rows = c.fetchall()
    conn.close()

    if not rows:
        await ctx.send("‚úÖ Database tr·ªëng cho server n√†y.")
        return

    now = datetime.now(timezone.utc)
    results = []
    for row in rows:
        member_id = int(row["member_id"])
        last_seen = row["last_seen"]
        if not last_seen:
            continue
        last_seen_dt = datetime.fromisoformat(last_seen)
        days_off = (now - last_seen_dt).days
        if days_off >= INACTIVE_DAYS:
            member = guild.get_member(member_id)
            results.append((member, days_off, last_seen, member_id))

    if not results:
        await ctx.send(f"‚úÖ Kh√¥ng c√≥ th√†nh vi√™n n√†o offline ‚â• {INACTIVE_DAYS} ng√†y.")
        return

    # N·∫øu xu·∫•t CSV
    if export and export.lower() in ("csv", "file"):
        csv_path = BASE_DIR / f"offline_{guild.id}_{INACTIVE_DAYS}d.csv"
        with open(csv_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["member_id", "member_name", "days_offline", "last_seen"])
            for member, days_off, last_seen, member_id in results:
                name = f"{member.name}#{member.discriminator}" if member else "Kh√¥ng t√¨m th·∫•y"
                writer.writerow([member_id, name, days_off, last_seen])
        with open(csv_path, "rb") as f:
            await ctx.send(f"üì• Danh s√°ch th√†nh vi√™n offline ‚â• {INACTIVE_DAYS} ng√†y:", file=discord.File(f, filename=csv_path.name))
        os.remove(csv_path)
        return

    # N·∫øu ch·ªâ hi·ªÉn th·ªã embed
    per_page = 25
    chunks = [results[i:i+per_page] for i in range(0, len(results), per_page)]
    for i, chunk in enumerate(chunks, start=1):
        lines = []
        for member, days_off, last_seen, member_id in chunk:
            name = f"{member.mention}" if member else f"ID:{member_id}"
            lines.append(f"‚Ä¢ {name} ‚Äî üïì {days_off} ng√†y (last_seen: `{last_seen}`)")
        embed = make_embed(
            title=f"üìã Th√†nh vi√™n offline ‚â• {INACTIVE_DAYS} ng√†y ‚Äî Trang {i}/{len(chunks)}",
            description="\n".join(lines[:2000]),
            color=discord.Color.gold(),
            footer=f"T·ªïng: {len(results)} ng∆∞·ªùi"
        )
        await ctx.send(embed=embed)

@bot.command(help="Hi·ªÉn th·ªã danh s√°ch th√†nh vi√™n offline ‚â•1 ng√†y.")
async def list_off(ctx):
    guild = ctx.guild
    role = discord.utils.get(guild.roles, name=ROLE_NAME)
    if not role:
        await ctx.send(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y role '{ROLE_NAME}' trong server n√†y.")
        return

    conn = get_db_connection()
    c = conn.cursor()
    c.execute("SELECT member_id, last_seen FROM inactivity WHERE guild_id=?", (str(guild.id),))
    rows = c.fetchall()
    conn.close()

    now = datetime.now(timezone.utc)
    results = []

    for row in rows:
        member = guild.get_member(int(row["member_id"]))
        if not member or member.bot or str(member.status) != "offline":
            continue
        last_seen = row["last_seen"]
        if not last_seen:
            continue
        last_seen_dt = datetime.fromisoformat(last_seen)
        days_offline = (now - last_seen_dt).days
        if days_offline >= 1:
            results.append(f"‚Ä¢ {member.name}#{member.discriminator} ‚Äî üïì {days_offline} ng√†y offline")

    if results:
        msg = "üìã **Danh s√°ch th√†nh vi√™n offline ‚â•1 ng√†y:**\n" + "\n".join(results)
    else:
        msg = "‚úÖ Kh√¥ng c√≥ th√†nh vi√™n n√†o offline l√¢u."
    await ctx.send(msg)

@bot.command(help="G·ª° role ng·ªß ƒë√¥ng kh·ªèi m·ªôt th√†nh vi√™n c·ª• th·ªÉ.")
@commands.has_permissions(manage_roles=True)
async def removerole(ctx, member: discord.Member):
    guild = ctx.guild
    role = discord.utils.get(guild.roles, name=ROLE_NAME)
    if not role:
        await ctx.send(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y role '{ROLE_NAME}' trong server n√†y.")
        return

    try:
        await member.remove_roles(role)
        conn = get_db_connection()
        c = conn.cursor()
        c.execute("UPDATE inactivity SET role_added=0 WHERE member_id=?", (str(member.id),))
        conn.commit()
        conn.close()
        await ctx.send(f"‚úÖ ƒê√£ g·ª° role '{ROLE_NAME}' kh·ªèi {member.name}.")
    except Exception as e:
        await ctx.send(f"‚ö†Ô∏è L·ªói khi g·ª° role: {e}")

@bot.command(help="Xu·∫•t database inactivity th√†nh file CSV c√≥ t√™n ng∆∞·ªùi d√πng")
@commands.has_permissions(administrator=True)
async def exportcsv(ctx):
    csv_path = BASE_DIR / "inactivity_export.csv"
    conn = get_db_connection()
    c = conn.cursor()
    c.execute("SELECT member_id, guild_id, last_seen, role_added FROM inactivity")
    rows = c.fetchall()
    conn.close()

    if not rows:
        await ctx.send("‚ö†Ô∏è Database tr·ªëng.")
        return

    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["member_id", "member_name", "guild_id", "last_seen", "role_added"])
        for row in rows:
            guild = bot.get_guild(int(row["guild_id"]))
            member = guild.get_member(int(row["member_id"])) if guild else None
            name = f"{member.name}#{member.discriminator}" if member else "Kh√¥ng t√¨m th·∫•y"
            writer.writerow([row["member_id"], name, row["guild_id"], row["last_seen"], row["role_added"]])
    with open(csv_path, "rb") as f:
        await ctx.send(file=discord.File(f, filename="inactivity_export.csv"))
    os.remove(csv_path)

@bot.command(help="Ch·∫°y ki·ªÉm tra inactivity ngay l·∫≠p t·ª©c")
@commands.has_permissions(administrator=True)
async def runcheck(ctx):
    await ctx.send(embed=make_embed(title="üîé ƒêang ki·ªÉm tra...", color=discord.Color.blue()))
    await check_inactivity_once(ctx)
    await ctx.send(embed=make_embed(title="‚úÖ Ho√†n t·∫•t ki·ªÉm tra th·ªß c√¥ng", color=discord.Color.green()))

@bot.command(help="Ki·ªÉm tra l·∫°i nh·ªØng ng∆∞·ªùi ƒë√£ offline >= 30 ng√†y")
@commands.has_permissions(administrator=True)
async def recheck30days(ctx):
    await ctx.send(embed=make_embed(title="üîÅ ƒêang ki·ªÉm tra l·∫°i nh·ªØng ng∆∞·ªùi ƒë√£ offline ‚â• 30 ng√†y...", color=discord.Color.blue()))
    await check_inactivity_once(ctx, only_over_30=True)
    await ctx.send(embed=make_embed(title="‚úÖ Ho√†n t·∫•t recheck", color=discord.Color.green()))

@bot.command(help="G·ª≠i file database SQLite (.db)")
@commands.has_permissions(administrator=True)
async def exportdb(ctx):
    if os.path.exists(DB_PATH):
        await ctx.send(file=discord.File(DB_PATH))
    else:
        await ctx.send("‚ùå Kh√¥ng t√¨m th·∫•y file database.")

@bot.command(help="Ki·ªÉm tra bot c√≥ ho·∫°t ƒë·ªông kh√¥ng")
async def test(ctx):
    embed = make_embed(
        title="üß™ Bot Test",
        description="‚úÖ Bot ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng v√† t·ª± ki·ªÉm tra inactivity m·ªói 24 gi·ªù.",
        color=discord.Color.green(),
        fields=[("üïì L·ªãch ki·ªÉm tra", "24 gi·ªù/l·∫ßn", True)],
        footer="D√πng !runcheck ƒë·ªÉ ki·ªÉm tra ngay."
    )
    embed.set_thumbnail(url="https://files.catbox.moe/rvvejl.png")
    await ctx.send(embed=embed)

# ===== Event =====
@bot.event
async def on_ready():
    print(f"ü§ñ Bot {bot.user} ƒë√£ online!")
    await bot.change_presence(activity=discord.Game("Theo d√µi t√≠n ƒë·ªì üò¥"))
    if not check_inactivity.is_running():
        check_inactivity.start()
        print("üü¢ Task check_inactivity ƒë√£ start")

# ===== Run App =====
if __name__ == "__main__":
    from threading import Thread
    import time

    print("üü¢ Kh·ªüi ƒë·ªông Flask server...")
    Thread(target=run_flask, daemon=True).start()
    time.sleep(3)  # ƒê·ª£i Flask bind port

    print("üü¢ Flask s·∫µn s√†ng, kh·ªüi ch·∫°y bot...")
    if TOKEN:
        bot.run(TOKEN)
    else:
        print("‚ùå Thi·∫øu TOKEN trong bi·∫øn m√¥i tr∆∞·ªùng!")
